// <auto-generated />
//
// To parse this JSON data, add NuGet 'System.Text.Json' then do:
//    TEST - trivial change
//    using UrlboxSDK.Options.Resource;
//
//    var urlboxOptions = UrlboxOptions.FromJson(jsonString);
#nullable enable
#pragma warning disable CS8618
#pragma warning disable CS8601
#pragma warning disable CS8603

namespace UrlboxSDK.Options.Resource
{
    using System;
    using System.Collections.Generic;

    using System.Text.Json;
    using System.Text.Json.Serialization;
    using System.Globalization;

    public partial class UrlboxOptions
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("accept_cookies")]
        public bool? AcceptCookies { get; set; }

        /// <summary>
        /// Sets an `Accept-Language` header on requests to the target URL
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("accept_lang")]
        public string AcceptLang { get; set; }

        /// <summary>
        /// Sets the accurate of the Geolocation API in metres.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("accuracy")]
        public double? Accuracy { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("allow_coin")]
        public bool? AllowCoin { get; set; }

        /// <summary>
        /// By default, when Urlbox detects an infinite scrolling page, it does not attempt to
        /// continue scrolling to the bottom, as this could result in infinite scrolling! If you want
        /// to override this behaviour, pass `true` for this option.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("allow_infinite")]
        public bool? AllowInfinite { get; set; }

        /// <summary>
        /// Sets an `Authorization` header on requests to the target URL. Can be used to pass an auth
        /// token through to the site in order to 'login' before rendering.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("authorization")]
        public string Authorization { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("auto_crop")]
        public bool? AutoCrop { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("auto_crop_bg")]
        public string AutoCropBg { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("auto_crop_threshold")]
        public long? AutoCropThreshold { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("base_url")]
        public string BaseUrl { get; set; }

        /// <summary>
        /// Specify a hex code or CSS color string to use as the background color Some websites don't
        /// set a body background colour, and will show up as transparent backgrounds with PNG, or
        /// black when using JPG. Use this setting to set a background colour. If the website
        /// explicitly sets a transparent background on the html or body elements, this setting will
        /// be overridden.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("bg_color")]
        public string BgColor { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("blend_mode")]
        public string BlendMode { get; set; }

        /// <summary>
        /// Blocks requests from popular advertising networks from loading.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("block_ads")]
        public bool? BlockAds { get; set; }

        /// <summary>
        /// Block fetch requests from the target URL.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("block_fetch")]
        public bool? BlockFetch { get; set; }

        /// <summary>
        /// Blocks font requests
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("block_fonts")]
        public bool? BlockFonts { get; set; }

        /// <summary>
        /// Block frames.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("block_frames")]
        public bool? BlockFrames { get; set; }

        /// <summary>
        /// Blocks image requests
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("block_images")]
        public bool? BlockImages { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("block_manifests")]
        public bool? BlockManifests { get; set; }

        /// <summary>
        /// Block video and audio requests
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("block_medias")]
        public bool? BlockMedias { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("block_other")]
        public bool? BlockOther { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("block_pings")]
        public bool? BlockPings { get; set; }

        /// <summary>
        /// Prevent requests for javascript scripts from loading
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("block_scripts")]
        public bool? BlockScripts { get; set; }

        /// <summary>
        /// Block websocket requests.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("block_sockets")]
        public bool? BlockSockets { get; set; }

        /// <summary>
        /// Prevent stylesheet requests from loading
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("block_styles")]
        public bool? BlockStyles { get; set; }

        /// <summary>
        /// Block requests from specific domains from loading. You can use wildcard characters such
        /// as `*` to match subdomains.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("block_urls")]
        public string[] BlockUrls { get; set; }

        /// <summary>
        /// Block XHR requests from the target URL.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("block_xhr")]
        public bool? BlockXhr { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("browser")]
        public string Browser { get; set; }

        /// <summary>
        /// If your custom bucket is fronted by a CDN, you can set the host name here.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("cdn_host")]
        public string CdnHost { get; set; }

        /// <summary>
        /// Specifies an element selector to click before generating a screenshot or PDF Example:
        /// `#clickme` would click an element with `id="clickme"`.  Can be used multiple times to
        /// simulate multiple sequential click events. If the selector matches multiple elements,
        /// only the first element will be clicked.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("click")]
        public string[] Click { get; set; }

        /// <summary>
        /// Similar to the [`hide_cookie_banners`](#hide_cookie_banners) option, but instead of
        /// hiding the banners, this option attempts to click on the 'Accept' button, in order to
        /// accept cookies.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("click_accept")]
        public bool? ClickAccept { get; set; }

        /// <summary>
        /// Specifies an element selector to click before generating a screenshot or PDF Example:
        /// `.clickme` would click all elements with `class="clickme"`.  Can be used multiple times
        /// to simulate multiple sequential click events. If the selector matches multiple elements,
        /// all elements will be clicked.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("click_all")]
        public string[] ClickAll { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("click_all_x")]
        public string[] ClickAllX { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("click_x")]
        public string[] ClickX { get; set; }

        /// <summary>
        /// Clip the screenshot to the bounding box specified by `x,y,width,height`.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("clip")]
        public string Clip { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("color_profile")]
        public ColorProfile? ColorProfile { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("continue_on_nav_error")]
        public bool? ContinueOnNavError { get; set; }

        /// <summary>
        /// Sets a cookie on the request when loading the URL. Example: To set the cookie with key
        /// `Opt-In` to the value `yes`, you would set the value of this option to `Opt-In=yes`.
        /// Cookies can be passed as an array, to allow setting multiple cookies -
        /// e.g.`["Opt-In=yes","Session-Id=DMTIzNDU"]`. To achieve multiple cookies with render
        /// links, just set the cookie option multiple times, like
        /// `cookie=Opt-In%3Dyes&cookie=Session-Id%3DDMTIzNDU`. To set a specific domain on a cookie,
        /// you can do the following: `OptIn=yes;Domain=.mydomain.com`. You can set other attributes
        /// for the cookie such as `Path`, `HttpOnly` and `SameSite`
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("cookie")]
        public string[] Cookie { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("cookies")]
        public string[] Cookies { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("crop_width")]
        public long? CropWidth { get; set; }

        /// <summary>
        /// Inject custom CSS into the page
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("css")]
        public string Css { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("custom_data_variable")]
        public string CustomDataVariable { get; set; }

        /// <summary>
        /// Emulate dark mode on websites by setting `prefers-color-scheme: dark`
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("dark_mode")]
        public bool? DarkMode { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("debug")]
        public bool? Debug { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("debug_url")]
        public string DebugUrl { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("debug_video")]
        public bool? DebugVideo { get; set; }

        /// <summary>
        /// The amount of time to wait before Urlbox captures a render in milliseconds.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("delay")]
        public long? Delay { get; set; }

        /// <summary>
        /// Some pages have full-height backgrounds whose heights are set to 100% of the viewport.
        /// This can cause the backgrounds to get stretched when making a full page screenshot. If
        /// you are seeing this behaviour in your full page screenshots, pass `true` for this option.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("detect_full_height")]
        public bool? DetectFullHeight { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("disable_animations")]
        public bool? DisableAnimations { get; set; }

        /// <summary>
        /// Turns off javascript on the target URL.  ~> Enabling this option will prevent
        /// `full_page=true` and many other options, because having javascript disabled prevents
        /// Urlbox from evaluating code inside the page's context.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("disable_js")]
        public bool? DisableJs { get; set; }

        /// <summary>
        /// Prevents ligatures from being used. Useful when rendering a PDF, and you want to extract
        /// text which contains ligatures.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("disable_ligatures")]
        public bool? DisableLigatures { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("disable_web_security")]
        public bool? DisableWebSecurity { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("display_p3")]
        public bool? DisplayP3 { get; set; }

        /// <summary>
        /// Pass in a filename which sets the content-disposition header on the response. E.g.
        /// `download=myfilename.png` This will make the Urlbox link downloadable, and will prompt
        /// the user to save the file as `myfilename.png`
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("download")]
        public string Download { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("dpr")]
        public double? Dpr { get; set; }

        /// <summary>
        /// Sets the version of the urlbox rendering engine to use when rendering the page. This can
        /// be useful for testing how a page will render in the latest version of our rendering
        /// engine.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("engine_version")]
        public EngineVersion? EngineVersion { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("fail_if_captcha")]
        public bool? FailIfCaptcha { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("fail_if_cf_turnstile")]
        public bool? FailIfCfTurnstile { get; set; }

        /// <summary>
        /// Fails the request if the elements specified by `selector` or `wait_for` options are not
        /// found on the page after waiting for `wait_timeout`.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("fail_if_selector_missing")]
        public bool? FailIfSelectorMissing { get; set; }

        /// <summary>
        /// Fails the request if the element specified by `wait_to_leave` option is found on the page
        /// after waiting for `wait_timeout`.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("fail_if_selector_present")]
        public bool? FailIfSelectorPresent { get; set; }

        /// <summary>
        /// If `fail_on_4xx=true` and the requested URL returns a status code between 400 and 499,
        /// Urlbox will fail the request with error code 400 and the message: `Failed to render.
        /// Requested URL returned a 4xx error code and fail_on_4xx was true`
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("fail_on_4xx")]
        public bool? FailOn4Xx { get; set; }

        /// <summary>
        /// If `fail_on_5xx=true` and the requested URL returns a status code between 500 and 599,
        /// Urlbox will fail the request with error code 400 and message: `Failed to render.
        /// Requested URL returned a 5xx error code and fail_on_5xx was true`
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("fail_on_5xx")]
        public bool? FailOn5Xx { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("fail_on_metadata_error")]
        public bool? FailOnMetadataError { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("finalRetry")]
        public bool? FinalRetry { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("fix_full_height")]
        public bool? FixFullHeight { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("flash")]
        public bool? Flash { get; set; }

        /// <summary>
        /// Generate a fresh screenshot or PDF, instead of getting a cached version.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("force")]
        public bool? Force { get; set; }

        /// <summary>
        /// The output format of the resulting render.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("format")]
        public Format? Format { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("fragment")]
        public bool? Fragment { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("freeze_fixed")]
        public bool? FreezeFixed { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("from_html")]
        public bool? FromHtml { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("full_html")]
        public bool? FullHtml { get; set; }

        /// <summary>
        /// Specify whether to capture the full scrollable area of the website. For PDFs, `full_page`
        /// mode will attempt to capture the whole website onto one single page PDF document.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("full_page")]
        public bool? FullPage { get; set; }

        /// <summary>
        /// Whether to use scroll and stitch algorithm (the default) to render a full page
        /// screenshot, or to use the native full page screenshot algorithm, which is faster, but can
        /// be less accurate on some sites.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("full_page_mode")]
        public FullPageMode? FullPageMode { get; set; }

        /// <summary>
        /// When full_page=true, specify whether to capture the full width of the website, for
        /// example if the site is horizontally scrolling.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("full_width")]
        public bool? FullWidth { get; set; }

        /// <summary>
        /// Enable GPU acceleration to render 3D scenes and heavy WebGL content. This is a beta
        /// feature and requires pre-approval. Please contact support@urlbox.com to enable this
        /// feature on your account.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("gpu")]
        public bool? Gpu { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("hdr10")]
        public bool? Hdr10 { get; set; }

        /// <summary>
        /// Set a header on the request when loading the URL Example: To set the header with key
        /// `X-My-Header` to the value `SomeValue`, you would pass `header=X-My-Header%3DSomeValue`.
        /// This can be set multiple times, to set more than one header - e.g.
        /// `header=X-My-Header%3DSomeValue&header=X-My-Other-Header%3DSomeOtherValue`. As with all
        /// options passed via the query string, the header value must be URL encoded - so
        /// `X-My-Header=SomeValue` becomes `X-My-Header%3DSomeValue` in order to be interpreted
        /// correctly by Urlbox.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("header")]
        public string[] Header { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("headers")]
        public string[] Headers { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("headless")]
        public bool? Headless { get; set; }

        /// <summary>
        /// The viewport height of the browser, in pixels.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("height")]
        public long? Height { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("height_from")]
        public string HeightFrom { get; set; }

        /// <summary>
        /// Automatically hides cookie banners from most websites, by setting their style to
        /// `display: none !important;`
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("hide_cookie_banners")]
        public bool? HideCookieBanners { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("hide_headless")]
        public bool? HideHeadless { get; set; }

        /// <summary>
        /// Comma-delimited string of CSS element selectors that are hidden by setting their style to
        /// `display: none !important;`. Useful for hiding pop-ups.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("hide_selector")]
        public string HideSelector { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("hide_selector_x")]
        public string HideSelectorX { get; set; }

        /// <summary>
        /// Specify a string to highlight on the page before capturing a screenshot or PDF. To
        /// highlight multiple words, separate words with a pipe character e.g. Hello|World
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("highlight")]
        public string Highlight { get; set; }

        /// <summary>
        /// Specify the background color of the highlighted word.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("highlightbg")]
        public string Highlightbg { get; set; }

        /// <summary>
        /// Specify the text color of the highlighted word.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("highlightfg")]
        public string Highlightfg { get; set; }

        /// <summary>
        /// Specifies an element selector to hover over before generating a screenshot or PDF
        /// Example: `#hoverme` would hover over the element with `id="hoverme"`
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("hover")]
        public string[] Hover { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("hover_x")]
        public string[] HoverX { get; set; }

        /// <summary>
        /// The HTML you want to render.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("html")]
        public string Html { get; set; }

        /// <summary>
        /// Background colour to use when [img_fit](#img_fit) is `contain`, or [`img_pad`](#img_pad)
        /// is used, defaults to black without transparency
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("img_bg")]
        public string ImgBg { get; set; }

        /// <summary>
        /// How the screenshot should be resized or cropped to fit the dimensions when using
        /// [`thumb_width`](#thumb_width) and/or [`thumb_height`](#thumb_height) options
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("img_fit")]
        public ImgFit? ImgFit { get; set; }

        /// <summary>
        /// Pad the screenshot, giving it a border. Can either be a single pixel value that gets
        /// added to each side, or a comma delimited string of `top,right,bottom,left` pixel values.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("img_pad")]
        public string ImgPad { get; set; }

        /// <summary>
        /// How the image should be positioned when using an [`img_fit`](#img_fit) of `cover` or
        /// `contain`.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("img_position")]
        public ImgPosition? ImgPosition { get; set; }

        /// <summary>
        /// Execute custom JavaScript in the context of the page. The JS gets executed after the
        /// page's dom has loaded, but before the screenshot is taken. No need to use `load` etc
        /// event handlers to run code, as these events will already have fired by the time this JS
        /// gets executed. You can use `await` to wait for promises to resolve.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("js")]
        public string Js { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("json")]
        public bool? Json { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("jsx")]
        public string Jsx { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("kill_popups")]
        public bool? KillPopups { get; set; }

        /// <summary>
        /// Sets the latitude used to emulate the Geolocation API.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("latitude")]
        public double? Latitude { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("lazyload")]
        public bool? Lazyload { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("lightweight")]
        public bool? Lightweight { get; set; }

        /// <summary>
        /// Sets the longitude used to emulate the Geolocation API.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("longitude")]
        public double? Longitude { get; set; }

        /// <summary>
        /// For extremely lengthy websites, it may be preferable to limit the screenshot to a maximum
        /// height to prevent Urlbox from spending time scrolling and generating an enormous
        /// screenshot.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("max_height")]
        public long? MaxHeight { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("max_scroll_page_time")]
        public long? MaxScrollPageTime { get; set; }

        /// <summary>
        /// When Urlbox takes a `full_page` screenshot, the maximum height of each image section is
        /// set to 4096 pixels. If a sites height is greater than this value, Urlbox will start
        /// splitting the screenshot into sections. Sometimes it is worthwhile experimenting with
        /// this number.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("max_section_height")]
        public long? MaxSectionHeight { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("max_section_width")]
        public long? MaxSectionWidth { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("max_sections")]
        public long? MaxSections { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("max_width")]
        public long? MaxWidth { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("max_xsections")]
        public long? MaxXsections { get; set; }

        /// <summary>
        /// By default, when generating a PDF, the `print` CSS media query is used. To generate a PDF
        /// using the `screen` CSS, set this option to `screen`.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("media")]
        public Media? Media { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("metadata")]
        public bool? Metadata { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("minidelay")]
        public long? Minidelay { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("no_upload")]
        public bool? NoUpload { get; set; }

        /// <summary>
        /// Automatically remove white space from PDF. Occasionally a PDF will have a lot of trailing
        /// white space at the bottom of the page. This option will attempt to automatically crop the
        /// PDF to remove this white space.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("pdf_auto_crop")]
        public bool? PdfAutoCrop { get; set; }

        /// <summary>
        /// Sets whether to print background images in the PDF
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("pdf_background")]
        public bool? PdfBackground { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("pdf_dpi")]
        public double? PdfDpi { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("pdf_fit_to_page")]
        public bool? PdfFitToPage { get; set; }

        /// <summary>
        /// Change the default pdf footer that is shown on each page of the pdf when
        /// [`pdf_show_footer`](#pdf_show_footer) option is set. You have the option to show the
        /// following variables in the footer (or header) of the pdf: * current `date` * `title` of
        /// the page * `url` of the page * current `pageNumber` * the `totalPages` in the pdf
        /// document You can display these variables by creating empty divs or spans, with special
        /// css class names relating to the variable you want to show. For example, if you want to
        /// show the `date` followed by the `url`, you could use the following pdf footer template:
        /// `<div class="date"></div><div class="url"></div>`. The pdf footer template you set are
        /// inserted as the innerHTML of a parent div which is a flex container, and has
        /// `align-items` set to `flex-end`. There are also some helper classes for aligning the divs
        /// or spans. The following classes are available: * `left` - adds some left padding to the
        /// element and sets `flex: none`. * `center` - aligns the element and text to the center. *
        /// `right` - adds some right padding to the element and sets `flex: none`. * `text` - sets
        /// the text to 8pt. * `grow` - sets `flex: auto` on the element, allowing it to grow to fill
        /// the available space. The default pdf footer is: `<div class='url text left
        /// grow'></div><div class='text right'><span class='pageNumber'></span>/<span
        /// class='totalPages'></span></div>`. You can see exactly how the pdf page is constructed by
        /// looking at the [chromium pdf
        /// template](https://source.chromium.org/chromium/chromium/src/+/main:components/printing/resources/print_header_footer_template_page.html;l=101-105?q=header_footer%20&ss=chromium%2Fchromium%2Fsrc)
        /// in the chromium source repository.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("pdf_footer")]
        public string PdfFooter { get; set; }

        /// <summary>
        /// Change the default pdf header that is shown on each page of the pdf when
        /// [`pdf_show_header`](#pdf_show_header) option is set. You have the option to show the
        /// following variables in the header (or footer) of the pdf: * current `date` * `title` of
        /// the page * `url` of the page * current `pageNumber` * the `totalPages` in the pdf
        /// document You can display these variables by creating empty divs or spans, with special
        /// css class names relating to the variable you want to show. For example, if you want to
        /// show the `date` followed by the `url`, you could use the following pdf header template:
        /// `<div class="date"></div><div class="url"></div>`. The pdf header template you set are
        /// inserted as the innerHTML of a parent div which is a flex container, and has
        /// `align-items` set to `flex-start`. There are also some helper classes for aligning the
        /// divs or spans. The following classes are available: * `left` - adds some left padding to
        /// the element and sets `flex: none`. * `center` - aligns the element and text to the
        /// center. * `right` - adds some right padding to the element and sets `flex: none`. *
        /// `text` - sets the text to 8pt. * `grow` - sets `flex: auto` on the element, allowing it
        /// to grow to fill the available space. The default pdf header is: `<div class='date text
        /// left'></div><div class='title text center'></div>`. You can see exactly how the pdf page
        /// is constructed by looking at the [chromium pdf
        /// template](https://source.chromium.org/chromium/chromium/src/+/main:components/printing/resources/print_header_footer_template_page.html;l=98-100?q=header_footer%20&ss=chromium%2Fchromium%2Fsrc)
        /// in the chromium source repository.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("pdf_header")]
        public string PdfHeader { get; set; }

        /// <summary>
        /// Sets the margin of the PDF document.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("pdf_margin")]
        public PdfMargin? PdfMargin { get; set; }

        /// <summary>
        /// Sets a custom bottom margin on the PDF.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("pdf_margin_bottom")]
        public double? PdfMarginBottom { get; set; }

        /// <summary>
        /// Set a custom left margin on the PDF.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("pdf_margin_left")]
        public double? PdfMarginLeft { get; set; }

        /// <summary>
        /// Sets a custom right margin on the PDF.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("pdf_margin_right")]
        public double? PdfMarginRight { get; set; }

        /// <summary>
        /// Sets a custom top margin on the PDF.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("pdf_margin_top")]
        public double? PdfMarginTop { get; set; }

        /// <summary>
        /// Sets the orientation of the PDF.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("pdf_orientation")]
        public PdfOrientation? PdfOrientation { get; set; }

        /// <summary>
        /// Sets the PDF page height, in pixels.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("pdf_page_height")]
        public double? PdfPageHeight { get; set; }

        /// <summary>
        /// Sets the PDF page range to return.  By default, the page is split into a multi page
        /// document and returns all page. Use this option to restrict which pages should be returned.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("pdf_page_range")]
        public string PdfPageRange { get; set; }

        /// <summary>
        /// Sets the PDF page size.  Setting this option will take precedence over `pdf_page_width`
        /// and `pdf_page_height`.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("pdf_page_size")]
        public PdfPageSize? PdfPageSize { get; set; }

        /// <summary>
        /// Sets the PDF page width, in pixels.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("pdf_page_width")]
        public double? PdfPageWidth { get; set; }

        /// <summary>
        /// Sets the scale factor of the website content in the PDF. Valid values are numbers between
        /// 0.1 and 2.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("pdf_scale")]
        public double? PdfScale { get; set; }

        /// <summary>
        /// Whether to show the default pdf footer on each page of the pdf. The template of the
        /// footer can be changed by setting the [`pdf_footer`](#pdf_footer) option.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("pdf_show_footer")]
        public bool? PdfShowFooter { get; set; }

        /// <summary>
        /// Whether to show the default pdf header on each page of the pdf. The template of the
        /// header can be changed by setting the [`pdf_header`](#pdf_header) option.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("pdf_show_header")]
        public bool? PdfShowHeader { get; set; }

        /// <summary>
        /// Sets the `navigator.platform` that the browser will report for the request. Useful for
        /// getting around certain scripts that detect the platform.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("platform")]
        public string Platform { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("press_escape")]
        public bool? PressEscape { get; set; }

        /// <summary>
        /// Pass in a proxy server address to make screenshot requests via that server in the format
        /// `[address]:[port]`. If proxy authentication is required, you can use the following
        /// format: `[user]:[password]@[address]:[port]`.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("proxy")]
        public string Proxy { get; set; }

        /// <summary>
        /// The image quality of the resulting screenshot (JPEG/WebP only)
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("quality")]
        public long? Quality { get; set; }

        /// <summary>
        /// Make the pdf into a readable document by removing unnecessary elements such as navigation
        /// bars, ads, etc.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("readable")]
        public bool? Readable { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("rec2020")]
        public bool? Rec2020 { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("redirect_after")]
        public long? RedirectAfter { get; set; }

        /// <summary>
        /// Prefer less animations on websites by setting `prefers-reduced-motion: reduced`
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("reduced_motion")]
        public bool? ReducedMotion { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("refresh")]
        public bool? Refresh { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("refresh_after_scroll")]
        public bool? RefreshAfterScroll { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("reload")]
        public bool? Reload { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("reload_after_scroll")]
        public bool? ReloadAfterScroll { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("render_queue")]
        public string RenderQueue { get; set; }

        /// <summary>
        /// For render link requests, setting this option to `json` will change the response type of
        /// the Urlbox request to JSON. For the API, the default response type is JSON.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("response_type")]
        public ResponseType? ResponseType { get; set; }

        /// <summary>
        /// Take a 'retina' or high-definition screenshot, equivalent to setting a device pixel ratio
        /// of 2.0 or @2x. Please note that retina screenshots will be double the normal dimensions
        /// and will normally take slightly longer to process due to the much bigger image size.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("retina")]
        public bool? Retina { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("retry_on_nav_error")]
        public bool? RetryOnNavError { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("revisit")]
        public bool? Revisit { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("revisit_after_scroll")]
        public bool? RevisitAfterScroll { get; set; }

        /// <summary>
        /// Overrides the configured bucket to use when saving the render.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("s3_bucket")]
        public string S3Bucket { get; set; }

        /// <summary>
        /// You can change the endpoint URL to use an S3 compatible storage provider e.g.
        /// DigitalOcean Spaces, Minio, Wasabi, Cloudflare R2 and more.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("s3_endpoint")]
        public string S3Endpoint { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("s3_force_path_style")]
        public bool? S3ForcePathStyle { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("s3_key")]
        public string S3Key { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("s3_object_lock")]
        public bool? S3ObjectLock { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("s3_part_size")]
        public long? S3PartSize { get; set; }

        /// <summary>
        /// Sets the S3 path, including subdirectories and the filename, to use when saving the
        /// render in your S3-compatible bucket. ~> The extension (e.g. .png, .jpg or .pdf) will be
        /// provided automatically, and should not be included in `s3_path`.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("s3_path")]
        public string S3Path { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("s3_presigned_url")]
        public string S3PresignedUrl { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("s3_presigned_url_html")]
        public string S3PresignedUrlHtml { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("s3_presigned_url_markdown")]
        public string S3PresignedUrlMarkdown { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("s3_presigned_url_metadata")]
        public string S3PresignedUrlMetadata { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("s3_presigned_url_mhtml")]
        public string S3PresignedUrlMhtml { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("s3_private_bucket")]
        public bool? S3PrivateBucket { get; set; }

        /// <summary>
        /// Override the configured S3 region when saving the render.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("s3_region")]
        public string S3Region { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("s3_secret")]
        public string S3Secret { get; set; }

        /// <summary>
        /// Sets the s3 storage class.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("s3_storageclass")]
        public S3Storageclass? S3Storageclass { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("save_html")]
        public bool? SaveHtml { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("save_markdown")]
        public bool? SaveMarkdown { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("save_metadata")]
        public bool? SaveMetadata { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("save_mhtml")]
        public bool? SaveMhtml { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("scrgb_linear")]
        public bool? ScrgbLinear { get; set; }

        /// <summary>
        /// When Urlbox decides to split a screenshot into multiple sections, the scroll delay is the
        /// time to wait between taking the screenshots of each individual section, in milliseconds.
        /// While Urlbox does detect animations, and attempts to wait for them before taking a
        /// screenshot, this option could be used to force Urlbox to wait for a certain amount of
        /// time after scrolling to the next section, to wait for things like animations to finish.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("scroll_delay")]
        public long? ScrollDelay { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("scroll_height")]
        public long? ScrollHeight { get; set; }

        /// <summary>
        /// Sets how many pixels to scroll when scrolling the page to trigger lazy loading elements.
        /// By default, the scroll increment is set to the browser viewport height. Some pages' lazy
        /// loading elements only trigger when the scroll increment is smaller than this, however,
        /// e.g. 400px.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("scroll_increment")]
        public long? ScrollIncrement { get; set; }

        /// <summary>
        /// Scroll, to either an element or to a pixel offset from the top, before taking a screenshot
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("scroll_to")]
        public string ScrollTo { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("scroll_to_x")]
        public string ScrollToX { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("secure_mode")]
        public bool? SecureMode { get; set; }

        /// <summary>
        /// Take a screenshot of the element that matches this selector. By default, if the selector
        /// is not found, Urlbox will take a normal viewport screenshot. If you prefer Urlbox to fail
        /// the request when the selector is not found, pass `fail_if_selector_missing=true`.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("selector")]
        public string Selector { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("sharp_stitch")]
        public bool? SharpStitch { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("show_seams")]
        public bool? ShowSeams { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("show_sections")]
        public bool? ShowSections { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("skip_final_delay")]
        public bool? SkipFinalDelay { get; set; }

        /// <summary>
        /// Enabling `skip_scroll` will speed up renders by skipping an initial scroll through the
        /// page, which is used to trigger any lazy loading elements.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("skip_scroll")]
        public bool? SkipScroll { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("skip_webhooks")]
        public bool? SkipWebhooks { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("solve_captchas")]
        public bool? SolveCaptchas { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("solve_cf_turnstile")]
        public bool? SolveCfTurnstile { get; set; }

        /// <summary>
        /// The height of the generated thumbnail, in pixels. Omit for a full-size screenshot.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("thumb_height")]
        public long? ThumbHeight { get; set; }

        /// <summary>
        /// The width of the generated thumbnail, in pixels. Omit for a full-size screenshot.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("thumb_width")]
        public long? ThumbWidth { get; set; }

        /// <summary>
        /// The amount of time to wait for the requested URL to load, in milliseconds. The timeout
        /// value needs to be between 5,000 and 100,000 milliseconds. The default is 30000 or 30
        /// seconds.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("timeout")]
        public long? Timeout { get; set; }

        /// <summary>
        /// If a website has no background color set, the image will have a transparent background
        /// (PNG/WebP only)
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("transparent")]
        public bool? Transparent { get; set; }

        /// <summary>
        /// The duration to keep a screenshot or PDF in the cache, in seconds. ttl stands for 'time
        /// to live'. The default value is also the maximum value: `2592000` seconds (30 days).
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("ttl")]
        public long? Ttl { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("turbo")]
        public bool? Turbo { get; set; }

        /// <summary>
        /// Emulate the timezone to use when rendering pages. Example: `tz=Europe/London`. A list of
        /// timezone ID's can be found here:
        /// https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("tz")]
        public string Tz { get; set; }

        /// <summary>
        /// Pass a unique string such as a UUID, hash or timestamp, to have more control over when to
        /// generate a fresh screenshot or PDF.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("unique")]
        public string Unique { get; set; }

        /// <summary>
        /// The URL or domain of the website you want to screenshot. We will automatically prepend
        /// `http://` if it is missing.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("url")]
        public string Url { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("use_chrome")]
        public bool? UseChrome { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("use_chromium")]
        public bool? UseChromium { get; set; }

        /// <summary>
        /// Save the render directly to the S3 (or S3-Compatible) bucket configured on your account.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("use_s3")]
        public bool? UseS3 { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("use_stealth")]
        public bool? UseStealth { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("use_tailwind")]
        public bool? UseTailwind { get; set; }

        /// <summary>
        /// Sets the `User-Agent` string for the request The presets are:  * `random` - Uses a random
        /// user-agent to help avoid bot detection * `mobile` - Uses a 'mobile-like' user-agent
        /// string * `desktop` - Uses a 'desktop' user-agent string This can be used in some cases to
        /// emulate certain device types, like mobile phones or tablets.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("user_agent")]
        public string UserAgent { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("v")]
        public EngineVersion? V { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_aspect")]
        public long? VideoAspect { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_bitrate")]
        public long? VideoBitrate { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_bits_per_second")]
        public long? VideoBitsPerSecond { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_chrome_height")]
        public long? VideoChromeHeight { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_codec")]
        public VideoCodec? VideoCodec { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_crop_w")]
        public long? VideoCropW { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_dont_scroll_back")]
        public bool? VideoDontScrollBack { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_ease")]
        public VideoEase? VideoEase { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_ease_end")]
        public VideoEase? VideoEaseEnd { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_ffmpeg")]
        public string[] VideoFfmpeg { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_fps")]
        public long? VideoFps { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_height")]
        public long? VideoHeight { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_jitter")]
        public double? VideoJitter { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_method")]
        public VideoMethod? VideoMethod { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_postscroll_duration")]
        public long? VideoPostscrollDuration { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_prescroll_duration")]
        public long? VideoPrescrollDuration { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_preset")]
        public VideoPreset? VideoPreset { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_quality")]
        public long? VideoQuality { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_refs")]
        public long? VideoRefs { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_rest_duration")]
        public long? VideoRestDuration { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_scroll")]
        public bool? VideoScroll { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_scroll_back_duration")]
        public long? VideoScrollBackDuration { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_scroll_distance")]
        public long? VideoScrollDistance { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_scroll_duration")]
        public long? VideoScrollDuration { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_seek")]
        public double? VideoSeek { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_time")]
        public long? VideoTime { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_use_iscroll")]
        public bool? VideoUseIscroll { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("video_width")]
        public long? VideoWidth { get; set; }

        /// <summary>
        /// Waits for the element specified by this selector to be present in the DOM before taking a
        /// screenshot or PDF.  By default, Urlbox will take a screenshot or PDF if the `wait_for`
        /// element is not found after waiting for the time specified by the
        /// [`wait_timeout`](#wait_timeout) option. If you prefer Urlbox to fail the request when the
        /// `wait_for` element is not found, pass
        /// [`fail_if_selector_missing=true`](#fail_if_selector_missing)
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("wait_for")]
        public string WaitFor { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("wait_for_x")]
        public string WaitForX { get; set; }

        /// <summary>
        /// The amount of time to wait for the [`wait_for`](#wait_for) element to appear, or the
        /// [`wait_to_leave`](#wait_to_leave) element to leave before continuing, in milliseconds.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("wait_timeout")]
        public long? WaitTimeout { get; set; }

        /// <summary>
        /// Waits for the element specified by this selector to be absent from the DOM before taking
        /// a screenshot or PDF.  A typical use-case would be waiting for loading spinners to be
        /// absent before taking a screenshot.  By default, Urlbox will take a screenshot or PDF if
        /// the `wait_to_leave` element is still present after the time specified by the
        /// [`wait_timeout`](#wait_timeout) option.  If you prefer Urlbox to fail the request when
        /// the `wait_to_leave` element is still present, pass
        /// [`fail_if_selector_present=true`](#fail_if_selector_present)
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("wait_to_leave")]
        public string WaitToLeave { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("wait_to_leave_x")]
        public string WaitToLeaveX { get; set; }

        /// <summary>
        /// Waits until the specified DOM event has fired before capturing a render. The available
        /// options are: * `domloaded` (the `DOMContentLoaded` event is fired) *
        /// `mostrequestsfinished` (consider navigation to be finished when there are no more than 2
        /// network connections for at least 500 ms) * `requestsfinished` (there are no more than 0
        /// network connections for at least 500 ms) * `loaded` (the `load` event is fired)
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("wait_until")]
        public WaitUntil? WaitUntil { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("watermark")]
        public bool? Watermark { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("webhook_url")]
        public string WebhookUrl { get; set; }

        /// <summary>
        /// The viewport width of the browser, in pixels.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("width")]
        public long? Width { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("width_from")]
        public string WidthFrom { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("wrap")]
        public string Wrap { get; set; }
    }

    public enum ColorProfile { Colorspingamma24, Default, Dp3, Hdr10, Rec2020, Scrgblinear, Srgb };

    /// <summary>
    /// Sets the version of the urlbox rendering engine to use when rendering the page. This can
    /// be useful for testing how a page will render in the latest version of our rendering
    /// engine.
    /// </summary>
    public enum EngineVersion { Latest, Lts, Stable };

    /// <summary>
    /// The output format of the resulting render.
    /// </summary>
    public enum Format { Avif, Html, Jpeg, Jpg, Md, Mhtml, Mp4, Pdf, Png, Svg, Webm, Webp };

    /// <summary>
    /// Whether to use scroll and stitch algorithm (the default) to render a full page
    /// screenshot, or to use the native full page screenshot algorithm, which is faster, but can
    /// be less accurate on some sites.
    /// </summary>
    public enum FullPageMode { Native, Stitch };

    /// <summary>
    /// How the screenshot should be resized or cropped to fit the dimensions when using
    /// [`thumb_width`](#thumb_width) and/or [`thumb_height`](#thumb_height) options
    /// </summary>
    public enum ImgFit { Contain, Cover, Fill, Inside, Outside };

    /// <summary>
    /// How the image should be positioned when using an [`img_fit`](#img_fit) of `cover` or
    /// `contain`.
    /// </summary>
    public enum ImgPosition { Attention, Bottom, Center, Centre, East, Entropy, Left, LeftBottom, LeftTop, North, Northeast, Northwest, Right, RightBottom, RightTop, South, Southeast, Southwest, Top, West };

    /// <summary>
    /// By default, when generating a PDF, the `print` CSS media query is used. To generate a PDF
    /// using the `screen` CSS, set this option to `screen`.
    /// </summary>
    public enum Media { Print, Screen };

    /// <summary>
    /// Sets the margin of the PDF document.
    /// </summary>
    public enum PdfMargin { Default, Minimum, None };

    /// <summary>
    /// Sets the orientation of the PDF.
    /// </summary>
    public enum PdfOrientation { Landscape, Portrait };

    /// <summary>
    /// Sets the PDF page size.  Setting this option will take precedence over `pdf_page_width`
    /// and `pdf_page_height`.
    /// </summary>
    public enum PdfPageSize { A0, A1, A2, A3, A4, A5, A6, Ledger, Legal, Letter, PdfPageSizeA0, PdfPageSizeA1, PdfPageSizeA2, PdfPageSizeA3, PdfPageSizeA4, PdfPageSizeA5, PdfPageSizeA6, PdfPageSizeLedger, PdfPageSizeLegal, PdfPageSizeLetter, PdfPageSizeTabloid, Tabloid };

    /// <summary>
    /// For render link requests, setting this option to `json` will change the response type of
    /// the Urlbox request to JSON. For the API, the default response type is JSON.
    /// </summary>
    public enum ResponseType { Base64, Binary, Json, Jsondebug, None };

    /// <summary>
    /// Sets the s3 storage class.
    /// </summary>
    public enum S3Storageclass { DeepArchive, Glacier, IntelligentTiering, OnezoneIa, Outposts, ReducedRedundancy, S3StorageclassDeepArchive, S3StorageclassGlacier, S3StorageclassIntelligentTiering, S3StorageclassOnezoneIa, S3StorageclassOutposts, S3StorageclassReducedRedundancy, S3StorageclassStandard, S3StorageclassStandardIa, Standard, StandardIa };

    public enum VideoCodec { H264, Vp8, Vp9 };

    public enum VideoEase { BackIn, BackInout, BackOut, BounceIn, BounceInout, BounceOut, CircularIn, CircularInout, CircularOut, CubicIn, CubicInout, CubicOut, ElasticIn, ElasticInout, ElasticOut, ExponentialIn, ExponentialInout, ExponentialOut, LinearNone, QuadraticIn, QuadraticInout, QuadraticOut, QuarticIn, QuarticInout, QuarticOut, QuinticIn, QuinticInout, QuinticOut, SinusoidalIn, SinusoidalInout, SinusoidalOut };

    public enum VideoMethod { Extension, Psr, Screencast };

    public enum VideoPreset { Fast, Faster, Medium, Slow, Slower, Superfast, Ultrafast, Veryfast, Veryslow };

    /// <summary>
    /// Waits until the specified DOM event has fired before capturing a render. The available
    /// options are: * `domloaded` (the `DOMContentLoaded` event is fired) *
    /// `mostrequestsfinished` (consider navigation to be finished when there are no more than 2
    /// network connections for at least 500 ms) * `requestsfinished` (there are no more than 0
    /// network connections for at least 500 ms) * `loaded` (the `load` event is fired)
    /// </summary>
    public enum WaitUntil { Domloaded, Loaded, Mostrequestsfinished, Requestsfinished };

    public partial class UrlboxOptions
    {
        public static UrlboxOptions FromJson(string json) => JsonSerializer.Deserialize<UrlboxOptions>(json, UrlboxSDK.Options.Resource.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this UrlboxOptions self) => JsonSerializer.Serialize(self, UrlboxSDK.Options.Resource.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerOptions Settings = new(JsonSerializerDefaults.General)
        {
            Converters =
            {
                ColorProfileConverter.Singleton,
                EngineVersionConverter.Singleton,
                FormatConverter.Singleton,
                FullPageModeConverter.Singleton,
                ImgFitConverter.Singleton,
                ImgPositionConverter.Singleton,
                MediaConverter.Singleton,
                PdfMarginConverter.Singleton,
                PdfOrientationConverter.Singleton,
                PdfPageSizeConverter.Singleton,
                ResponseTypeConverter.Singleton,
                S3StorageclassConverter.Singleton,
                VideoCodecConverter.Singleton,
                VideoEaseConverter.Singleton,
                VideoMethodConverter.Singleton,
                VideoPresetConverter.Singleton,
                WaitUntilConverter.Singleton,
                new DateOnlyConverter(),
                new TimeOnlyConverter(),
                IsoDateTimeOffsetConverter.Singleton
            },
        };
    }

    internal class ColorProfileConverter : JsonConverter<ColorProfile>
    {
        public override bool CanConvert(Type t) => t == typeof(ColorProfile);

        public override ColorProfile Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "colorspingamma24":
                    return ColorProfile.Colorspingamma24;
                case "default":
                    return ColorProfile.Default;
                case "dp3":
                    return ColorProfile.Dp3;
                case "hdr10":
                    return ColorProfile.Hdr10;
                case "rec2020":
                    return ColorProfile.Rec2020;
                case "scrgblinear":
                    return ColorProfile.Scrgblinear;
                case "srgb":
                    return ColorProfile.Srgb;
            }
            throw new Exception("Cannot unmarshal type ColorProfile");
        }

        public override void Write(Utf8JsonWriter writer, ColorProfile value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case ColorProfile.Colorspingamma24:
                    JsonSerializer.Serialize(writer, "colorspingamma24", options);
                    return;
                case ColorProfile.Default:
                    JsonSerializer.Serialize(writer, "default", options);
                    return;
                case ColorProfile.Dp3:
                    JsonSerializer.Serialize(writer, "dp3", options);
                    return;
                case ColorProfile.Hdr10:
                    JsonSerializer.Serialize(writer, "hdr10", options);
                    return;
                case ColorProfile.Rec2020:
                    JsonSerializer.Serialize(writer, "rec2020", options);
                    return;
                case ColorProfile.Scrgblinear:
                    JsonSerializer.Serialize(writer, "scrgblinear", options);
                    return;
                case ColorProfile.Srgb:
                    JsonSerializer.Serialize(writer, "srgb", options);
                    return;
            }
            throw new Exception("Cannot marshal type ColorProfile");
        }

        public static readonly ColorProfileConverter Singleton = new ColorProfileConverter();
    }

    internal class EngineVersionConverter : JsonConverter<EngineVersion>
    {
        public override bool CanConvert(Type t) => t == typeof(EngineVersion);

        public override EngineVersion Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "latest":
                    return EngineVersion.Latest;
                case "lts":
                    return EngineVersion.Lts;
                case "stable":
                    return EngineVersion.Stable;
            }
            throw new Exception("Cannot unmarshal type EngineVersion");
        }

        public override void Write(Utf8JsonWriter writer, EngineVersion value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case EngineVersion.Latest:
                    JsonSerializer.Serialize(writer, "latest", options);
                    return;
                case EngineVersion.Lts:
                    JsonSerializer.Serialize(writer, "lts", options);
                    return;
                case EngineVersion.Stable:
                    JsonSerializer.Serialize(writer, "stable", options);
                    return;
            }
            throw new Exception("Cannot marshal type EngineVersion");
        }

        public static readonly EngineVersionConverter Singleton = new EngineVersionConverter();
    }

    internal class FormatConverter : JsonConverter<Format>
    {
        public override bool CanConvert(Type t) => t == typeof(Format);

        public override Format Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "avif":
                    return Format.Avif;
                case "html":
                    return Format.Html;
                case "jpeg":
                    return Format.Jpeg;
                case "jpg":
                    return Format.Jpg;
                case "md":
                    return Format.Md;
                case "mhtml":
                    return Format.Mhtml;
                case "mp4":
                    return Format.Mp4;
                case "pdf":
                    return Format.Pdf;
                case "png":
                    return Format.Png;
                case "svg":
                    return Format.Svg;
                case "webm":
                    return Format.Webm;
                case "webp":
                    return Format.Webp;
            }
            throw new Exception("Cannot unmarshal type Format");
        }

        public override void Write(Utf8JsonWriter writer, Format value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case Format.Avif:
                    JsonSerializer.Serialize(writer, "avif", options);
                    return;
                case Format.Html:
                    JsonSerializer.Serialize(writer, "html", options);
                    return;
                case Format.Jpeg:
                    JsonSerializer.Serialize(writer, "jpeg", options);
                    return;
                case Format.Jpg:
                    JsonSerializer.Serialize(writer, "jpg", options);
                    return;
                case Format.Md:
                    JsonSerializer.Serialize(writer, "md", options);
                    return;
                case Format.Mhtml:
                    JsonSerializer.Serialize(writer, "mhtml", options);
                    return;
                case Format.Mp4:
                    JsonSerializer.Serialize(writer, "mp4", options);
                    return;
                case Format.Pdf:
                    JsonSerializer.Serialize(writer, "pdf", options);
                    return;
                case Format.Png:
                    JsonSerializer.Serialize(writer, "png", options);
                    return;
                case Format.Svg:
                    JsonSerializer.Serialize(writer, "svg", options);
                    return;
                case Format.Webm:
                    JsonSerializer.Serialize(writer, "webm", options);
                    return;
                case Format.Webp:
                    JsonSerializer.Serialize(writer, "webp", options);
                    return;
            }
            throw new Exception("Cannot marshal type Format");
        }

        public static readonly FormatConverter Singleton = new FormatConverter();
    }

    internal class FullPageModeConverter : JsonConverter<FullPageMode>
    {
        public override bool CanConvert(Type t) => t == typeof(FullPageMode);

        public override FullPageMode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "native":
                    return FullPageMode.Native;
                case "stitch":
                    return FullPageMode.Stitch;
            }
            throw new Exception("Cannot unmarshal type FullPageMode");
        }

        public override void Write(Utf8JsonWriter writer, FullPageMode value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case FullPageMode.Native:
                    JsonSerializer.Serialize(writer, "native", options);
                    return;
                case FullPageMode.Stitch:
                    JsonSerializer.Serialize(writer, "stitch", options);
                    return;
            }
            throw new Exception("Cannot marshal type FullPageMode");
        }

        public static readonly FullPageModeConverter Singleton = new FullPageModeConverter();
    }

    internal class ImgFitConverter : JsonConverter<ImgFit>
    {
        public override bool CanConvert(Type t) => t == typeof(ImgFit);

        public override ImgFit Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "contain":
                    return ImgFit.Contain;
                case "cover":
                    return ImgFit.Cover;
                case "fill":
                    return ImgFit.Fill;
                case "inside":
                    return ImgFit.Inside;
                case "outside":
                    return ImgFit.Outside;
            }
            throw new Exception("Cannot unmarshal type ImgFit");
        }

        public override void Write(Utf8JsonWriter writer, ImgFit value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case ImgFit.Contain:
                    JsonSerializer.Serialize(writer, "contain", options);
                    return;
                case ImgFit.Cover:
                    JsonSerializer.Serialize(writer, "cover", options);
                    return;
                case ImgFit.Fill:
                    JsonSerializer.Serialize(writer, "fill", options);
                    return;
                case ImgFit.Inside:
                    JsonSerializer.Serialize(writer, "inside", options);
                    return;
                case ImgFit.Outside:
                    JsonSerializer.Serialize(writer, "outside", options);
                    return;
            }
            throw new Exception("Cannot marshal type ImgFit");
        }

        public static readonly ImgFitConverter Singleton = new ImgFitConverter();
    }

    internal class ImgPositionConverter : JsonConverter<ImgPosition>
    {
        public override bool CanConvert(Type t) => t == typeof(ImgPosition);

        public override ImgPosition Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "attention":
                    return ImgPosition.Attention;
                case "bottom":
                    return ImgPosition.Bottom;
                case "center":
                    return ImgPosition.Center;
                case "centre":
                    return ImgPosition.Centre;
                case "east":
                    return ImgPosition.East;
                case "entropy":
                    return ImgPosition.Entropy;
                case "left":
                    return ImgPosition.Left;
                case "left bottom":
                    return ImgPosition.LeftBottom;
                case "left top":
                    return ImgPosition.LeftTop;
                case "north":
                    return ImgPosition.North;
                case "northeast":
                    return ImgPosition.Northeast;
                case "northwest":
                    return ImgPosition.Northwest;
                case "right":
                    return ImgPosition.Right;
                case "right bottom":
                    return ImgPosition.RightBottom;
                case "right top":
                    return ImgPosition.RightTop;
                case "south":
                    return ImgPosition.South;
                case "southeast":
                    return ImgPosition.Southeast;
                case "southwest":
                    return ImgPosition.Southwest;
                case "top":
                    return ImgPosition.Top;
                case "west":
                    return ImgPosition.West;
            }
            throw new Exception("Cannot unmarshal type ImgPosition");
        }

        public override void Write(Utf8JsonWriter writer, ImgPosition value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case ImgPosition.Attention:
                    JsonSerializer.Serialize(writer, "attention", options);
                    return;
                case ImgPosition.Bottom:
                    JsonSerializer.Serialize(writer, "bottom", options);
                    return;
                case ImgPosition.Center:
                    JsonSerializer.Serialize(writer, "center", options);
                    return;
                case ImgPosition.Centre:
                    JsonSerializer.Serialize(writer, "centre", options);
                    return;
                case ImgPosition.East:
                    JsonSerializer.Serialize(writer, "east", options);
                    return;
                case ImgPosition.Entropy:
                    JsonSerializer.Serialize(writer, "entropy", options);
                    return;
                case ImgPosition.Left:
                    JsonSerializer.Serialize(writer, "left", options);
                    return;
                case ImgPosition.LeftBottom:
                    JsonSerializer.Serialize(writer, "left bottom", options);
                    return;
                case ImgPosition.LeftTop:
                    JsonSerializer.Serialize(writer, "left top", options);
                    return;
                case ImgPosition.North:
                    JsonSerializer.Serialize(writer, "north", options);
                    return;
                case ImgPosition.Northeast:
                    JsonSerializer.Serialize(writer, "northeast", options);
                    return;
                case ImgPosition.Northwest:
                    JsonSerializer.Serialize(writer, "northwest", options);
                    return;
                case ImgPosition.Right:
                    JsonSerializer.Serialize(writer, "right", options);
                    return;
                case ImgPosition.RightBottom:
                    JsonSerializer.Serialize(writer, "right bottom", options);
                    return;
                case ImgPosition.RightTop:
                    JsonSerializer.Serialize(writer, "right top", options);
                    return;
                case ImgPosition.South:
                    JsonSerializer.Serialize(writer, "south", options);
                    return;
                case ImgPosition.Southeast:
                    JsonSerializer.Serialize(writer, "southeast", options);
                    return;
                case ImgPosition.Southwest:
                    JsonSerializer.Serialize(writer, "southwest", options);
                    return;
                case ImgPosition.Top:
                    JsonSerializer.Serialize(writer, "top", options);
                    return;
                case ImgPosition.West:
                    JsonSerializer.Serialize(writer, "west", options);
                    return;
            }
            throw new Exception("Cannot marshal type ImgPosition");
        }

        public static readonly ImgPositionConverter Singleton = new ImgPositionConverter();
    }

    internal class MediaConverter : JsonConverter<Media>
    {
        public override bool CanConvert(Type t) => t == typeof(Media);

        public override Media Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "print":
                    return Media.Print;
                case "screen":
                    return Media.Screen;
            }
            throw new Exception("Cannot unmarshal type Media");
        }

        public override void Write(Utf8JsonWriter writer, Media value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case Media.Print:
                    JsonSerializer.Serialize(writer, "print", options);
                    return;
                case Media.Screen:
                    JsonSerializer.Serialize(writer, "screen", options);
                    return;
            }
            throw new Exception("Cannot marshal type Media");
        }

        public static readonly MediaConverter Singleton = new MediaConverter();
    }

    internal class PdfMarginConverter : JsonConverter<PdfMargin>
    {
        public override bool CanConvert(Type t) => t == typeof(PdfMargin);

        public override PdfMargin Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "default":
                    return PdfMargin.Default;
                case "minimum":
                    return PdfMargin.Minimum;
                case "none":
                    return PdfMargin.None;
            }
            throw new Exception("Cannot unmarshal type PdfMargin");
        }

        public override void Write(Utf8JsonWriter writer, PdfMargin value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case PdfMargin.Default:
                    JsonSerializer.Serialize(writer, "default", options);
                    return;
                case PdfMargin.Minimum:
                    JsonSerializer.Serialize(writer, "minimum", options);
                    return;
                case PdfMargin.None:
                    JsonSerializer.Serialize(writer, "none", options);
                    return;
            }
            throw new Exception("Cannot marshal type PdfMargin");
        }

        public static readonly PdfMarginConverter Singleton = new PdfMarginConverter();
    }

    internal class PdfOrientationConverter : JsonConverter<PdfOrientation>
    {
        public override bool CanConvert(Type t) => t == typeof(PdfOrientation);

        public override PdfOrientation Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "landscape":
                    return PdfOrientation.Landscape;
                case "portrait":
                    return PdfOrientation.Portrait;
            }
            throw new Exception("Cannot unmarshal type PdfOrientation");
        }

        public override void Write(Utf8JsonWriter writer, PdfOrientation value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case PdfOrientation.Landscape:
                    JsonSerializer.Serialize(writer, "landscape", options);
                    return;
                case PdfOrientation.Portrait:
                    JsonSerializer.Serialize(writer, "portrait", options);
                    return;
            }
            throw new Exception("Cannot marshal type PdfOrientation");
        }

        public static readonly PdfOrientationConverter Singleton = new PdfOrientationConverter();
    }

    internal class PdfPageSizeConverter : JsonConverter<PdfPageSize>
    {
        public override bool CanConvert(Type t) => t == typeof(PdfPageSize);

        public override PdfPageSize Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "A0":
                    return PdfPageSize.PdfPageSizeA0;
                case "A1":
                    return PdfPageSize.PdfPageSizeA1;
                case "A2":
                    return PdfPageSize.PdfPageSizeA2;
                case "A3":
                    return PdfPageSize.PdfPageSizeA3;
                case "A4":
                    return PdfPageSize.PdfPageSizeA4;
                case "A5":
                    return PdfPageSize.PdfPageSizeA5;
                case "A6":
                    return PdfPageSize.PdfPageSizeA6;
                case "Ledger":
                    return PdfPageSize.PdfPageSizeLedger;
                case "Legal":
                    return PdfPageSize.PdfPageSizeLegal;
                case "Letter":
                    return PdfPageSize.PdfPageSizeLetter;
                case "Tabloid":
                    return PdfPageSize.PdfPageSizeTabloid;
                case "a0":
                    return PdfPageSize.A0;
                case "a1":
                    return PdfPageSize.A1;
                case "a2":
                    return PdfPageSize.A2;
                case "a3":
                    return PdfPageSize.A3;
                case "a4":
                    return PdfPageSize.A4;
                case "a5":
                    return PdfPageSize.A5;
                case "a6":
                    return PdfPageSize.A6;
                case "ledger":
                    return PdfPageSize.Ledger;
                case "legal":
                    return PdfPageSize.Legal;
                case "letter":
                    return PdfPageSize.Letter;
                case "tabloid":
                    return PdfPageSize.Tabloid;
            }
            throw new Exception("Cannot unmarshal type PdfPageSize");
        }

        public override void Write(Utf8JsonWriter writer, PdfPageSize value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case PdfPageSize.PdfPageSizeA0:
                    JsonSerializer.Serialize(writer, "A0", options);
                    return;
                case PdfPageSize.PdfPageSizeA1:
                    JsonSerializer.Serialize(writer, "A1", options);
                    return;
                case PdfPageSize.PdfPageSizeA2:
                    JsonSerializer.Serialize(writer, "A2", options);
                    return;
                case PdfPageSize.PdfPageSizeA3:
                    JsonSerializer.Serialize(writer, "A3", options);
                    return;
                case PdfPageSize.PdfPageSizeA4:
                    JsonSerializer.Serialize(writer, "A4", options);
                    return;
                case PdfPageSize.PdfPageSizeA5:
                    JsonSerializer.Serialize(writer, "A5", options);
                    return;
                case PdfPageSize.PdfPageSizeA6:
                    JsonSerializer.Serialize(writer, "A6", options);
                    return;
                case PdfPageSize.PdfPageSizeLedger:
                    JsonSerializer.Serialize(writer, "Ledger", options);
                    return;
                case PdfPageSize.PdfPageSizeLegal:
                    JsonSerializer.Serialize(writer, "Legal", options);
                    return;
                case PdfPageSize.PdfPageSizeLetter:
                    JsonSerializer.Serialize(writer, "Letter", options);
                    return;
                case PdfPageSize.PdfPageSizeTabloid:
                    JsonSerializer.Serialize(writer, "Tabloid", options);
                    return;
                case PdfPageSize.A0:
                    JsonSerializer.Serialize(writer, "a0", options);
                    return;
                case PdfPageSize.A1:
                    JsonSerializer.Serialize(writer, "a1", options);
                    return;
                case PdfPageSize.A2:
                    JsonSerializer.Serialize(writer, "a2", options);
                    return;
                case PdfPageSize.A3:
                    JsonSerializer.Serialize(writer, "a3", options);
                    return;
                case PdfPageSize.A4:
                    JsonSerializer.Serialize(writer, "a4", options);
                    return;
                case PdfPageSize.A5:
                    JsonSerializer.Serialize(writer, "a5", options);
                    return;
                case PdfPageSize.A6:
                    JsonSerializer.Serialize(writer, "a6", options);
                    return;
                case PdfPageSize.Ledger:
                    JsonSerializer.Serialize(writer, "ledger", options);
                    return;
                case PdfPageSize.Legal:
                    JsonSerializer.Serialize(writer, "legal", options);
                    return;
                case PdfPageSize.Letter:
                    JsonSerializer.Serialize(writer, "letter", options);
                    return;
                case PdfPageSize.Tabloid:
                    JsonSerializer.Serialize(writer, "tabloid", options);
                    return;
            }
            throw new Exception("Cannot marshal type PdfPageSize");
        }

        public static readonly PdfPageSizeConverter Singleton = new PdfPageSizeConverter();
    }

    internal class ResponseTypeConverter : JsonConverter<ResponseType>
    {
        public override bool CanConvert(Type t) => t == typeof(ResponseType);

        public override ResponseType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "base64":
                    return ResponseType.Base64;
                case "binary":
                    return ResponseType.Binary;
                case "json":
                    return ResponseType.Json;
                case "jsondebug":
                    return ResponseType.Jsondebug;
                case "none":
                    return ResponseType.None;
            }
            throw new Exception("Cannot unmarshal type ResponseType");
        }

        public override void Write(Utf8JsonWriter writer, ResponseType value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case ResponseType.Base64:
                    JsonSerializer.Serialize(writer, "base64", options);
                    return;
                case ResponseType.Binary:
                    JsonSerializer.Serialize(writer, "binary", options);
                    return;
                case ResponseType.Json:
                    JsonSerializer.Serialize(writer, "json", options);
                    return;
                case ResponseType.Jsondebug:
                    JsonSerializer.Serialize(writer, "jsondebug", options);
                    return;
                case ResponseType.None:
                    JsonSerializer.Serialize(writer, "none", options);
                    return;
            }
            throw new Exception("Cannot marshal type ResponseType");
        }

        public static readonly ResponseTypeConverter Singleton = new ResponseTypeConverter();
    }

    internal class S3StorageclassConverter : JsonConverter<S3Storageclass>
    {
        public override bool CanConvert(Type t) => t == typeof(S3Storageclass);

        public override S3Storageclass Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "DEEP_ARCHIVE":
                    return S3Storageclass.DeepArchive;
                case "GLACIER":
                    return S3Storageclass.Glacier;
                case "INTELLIGENT_TIERING":
                    return S3Storageclass.IntelligentTiering;
                case "ONEZONE_IA":
                    return S3Storageclass.OnezoneIa;
                case "OUTPOSTS":
                    return S3Storageclass.Outposts;
                case "REDUCED_REDUNDANCY":
                    return S3Storageclass.ReducedRedundancy;
                case "STANDARD":
                    return S3Storageclass.Standard;
                case "STANDARD_IA":
                    return S3Storageclass.StandardIa;
                case "deep_archive":
                    return S3Storageclass.S3StorageclassDeepArchive;
                case "glacier":
                    return S3Storageclass.S3StorageclassGlacier;
                case "intelligent_tiering":
                    return S3Storageclass.S3StorageclassIntelligentTiering;
                case "onezone_ia":
                    return S3Storageclass.S3StorageclassOnezoneIa;
                case "outposts":
                    return S3Storageclass.S3StorageclassOutposts;
                case "reduced_redundancy":
                    return S3Storageclass.S3StorageclassReducedRedundancy;
                case "standard":
                    return S3Storageclass.S3StorageclassStandard;
                case "standard_ia":
                    return S3Storageclass.S3StorageclassStandardIa;
            }
            throw new Exception("Cannot unmarshal type S3Storageclass");
        }

        public override void Write(Utf8JsonWriter writer, S3Storageclass value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case S3Storageclass.DeepArchive:
                    JsonSerializer.Serialize(writer, "DEEP_ARCHIVE", options);
                    return;
                case S3Storageclass.Glacier:
                    JsonSerializer.Serialize(writer, "GLACIER", options);
                    return;
                case S3Storageclass.IntelligentTiering:
                    JsonSerializer.Serialize(writer, "INTELLIGENT_TIERING", options);
                    return;
                case S3Storageclass.OnezoneIa:
                    JsonSerializer.Serialize(writer, "ONEZONE_IA", options);
                    return;
                case S3Storageclass.Outposts:
                    JsonSerializer.Serialize(writer, "OUTPOSTS", options);
                    return;
                case S3Storageclass.ReducedRedundancy:
                    JsonSerializer.Serialize(writer, "REDUCED_REDUNDANCY", options);
                    return;
                case S3Storageclass.Standard:
                    JsonSerializer.Serialize(writer, "STANDARD", options);
                    return;
                case S3Storageclass.StandardIa:
                    JsonSerializer.Serialize(writer, "STANDARD_IA", options);
                    return;
                case S3Storageclass.S3StorageclassDeepArchive:
                    JsonSerializer.Serialize(writer, "deep_archive", options);
                    return;
                case S3Storageclass.S3StorageclassGlacier:
                    JsonSerializer.Serialize(writer, "glacier", options);
                    return;
                case S3Storageclass.S3StorageclassIntelligentTiering:
                    JsonSerializer.Serialize(writer, "intelligent_tiering", options);
                    return;
                case S3Storageclass.S3StorageclassOnezoneIa:
                    JsonSerializer.Serialize(writer, "onezone_ia", options);
                    return;
                case S3Storageclass.S3StorageclassOutposts:
                    JsonSerializer.Serialize(writer, "outposts", options);
                    return;
                case S3Storageclass.S3StorageclassReducedRedundancy:
                    JsonSerializer.Serialize(writer, "reduced_redundancy", options);
                    return;
                case S3Storageclass.S3StorageclassStandard:
                    JsonSerializer.Serialize(writer, "standard", options);
                    return;
                case S3Storageclass.S3StorageclassStandardIa:
                    JsonSerializer.Serialize(writer, "standard_ia", options);
                    return;
            }
            throw new Exception("Cannot marshal type S3Storageclass");
        }

        public static readonly S3StorageclassConverter Singleton = new S3StorageclassConverter();
    }

    internal class VideoCodecConverter : JsonConverter<VideoCodec>
    {
        public override bool CanConvert(Type t) => t == typeof(VideoCodec);

        public override VideoCodec Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "h264":
                    return VideoCodec.H264;
                case "vp8":
                    return VideoCodec.Vp8;
                case "vp9":
                    return VideoCodec.Vp9;
            }
            throw new Exception("Cannot unmarshal type VideoCodec");
        }

        public override void Write(Utf8JsonWriter writer, VideoCodec value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case VideoCodec.H264:
                    JsonSerializer.Serialize(writer, "h264", options);
                    return;
                case VideoCodec.Vp8:
                    JsonSerializer.Serialize(writer, "vp8", options);
                    return;
                case VideoCodec.Vp9:
                    JsonSerializer.Serialize(writer, "vp9", options);
                    return;
            }
            throw new Exception("Cannot marshal type VideoCodec");
        }

        public static readonly VideoCodecConverter Singleton = new VideoCodecConverter();
    }

    internal class VideoEaseConverter : JsonConverter<VideoEase>
    {
        public override bool CanConvert(Type t) => t == typeof(VideoEase);

        public override VideoEase Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "back.in":
                    return VideoEase.BackIn;
                case "back.inout":
                    return VideoEase.BackInout;
                case "back.out":
                    return VideoEase.BackOut;
                case "bounce.in":
                    return VideoEase.BounceIn;
                case "bounce.inout":
                    return VideoEase.BounceInout;
                case "bounce.out":
                    return VideoEase.BounceOut;
                case "circular.in":
                    return VideoEase.CircularIn;
                case "circular.inout":
                    return VideoEase.CircularInout;
                case "circular.out":
                    return VideoEase.CircularOut;
                case "cubic.in":
                    return VideoEase.CubicIn;
                case "cubic.inout":
                    return VideoEase.CubicInout;
                case "cubic.out":
                    return VideoEase.CubicOut;
                case "elastic.in":
                    return VideoEase.ElasticIn;
                case "elastic.inout":
                    return VideoEase.ElasticInout;
                case "elastic.out":
                    return VideoEase.ElasticOut;
                case "exponential.in":
                    return VideoEase.ExponentialIn;
                case "exponential.inout":
                    return VideoEase.ExponentialInout;
                case "exponential.out":
                    return VideoEase.ExponentialOut;
                case "linear.none":
                    return VideoEase.LinearNone;
                case "quadratic.in":
                    return VideoEase.QuadraticIn;
                case "quadratic.inout":
                    return VideoEase.QuadraticInout;
                case "quadratic.out":
                    return VideoEase.QuadraticOut;
                case "quartic.in":
                    return VideoEase.QuarticIn;
                case "quartic.inout":
                    return VideoEase.QuarticInout;
                case "quartic.out":
                    return VideoEase.QuarticOut;
                case "quintic.in":
                    return VideoEase.QuinticIn;
                case "quintic.inout":
                    return VideoEase.QuinticInout;
                case "quintic.out":
                    return VideoEase.QuinticOut;
                case "sinusoidal.in":
                    return VideoEase.SinusoidalIn;
                case "sinusoidal.inout":
                    return VideoEase.SinusoidalInout;
                case "sinusoidal.out":
                    return VideoEase.SinusoidalOut;
            }
            throw new Exception("Cannot unmarshal type VideoEase");
        }

        public override void Write(Utf8JsonWriter writer, VideoEase value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case VideoEase.BackIn:
                    JsonSerializer.Serialize(writer, "back.in", options);
                    return;
                case VideoEase.BackInout:
                    JsonSerializer.Serialize(writer, "back.inout", options);
                    return;
                case VideoEase.BackOut:
                    JsonSerializer.Serialize(writer, "back.out", options);
                    return;
                case VideoEase.BounceIn:
                    JsonSerializer.Serialize(writer, "bounce.in", options);
                    return;
                case VideoEase.BounceInout:
                    JsonSerializer.Serialize(writer, "bounce.inout", options);
                    return;
                case VideoEase.BounceOut:
                    JsonSerializer.Serialize(writer, "bounce.out", options);
                    return;
                case VideoEase.CircularIn:
                    JsonSerializer.Serialize(writer, "circular.in", options);
                    return;
                case VideoEase.CircularInout:
                    JsonSerializer.Serialize(writer, "circular.inout", options);
                    return;
                case VideoEase.CircularOut:
                    JsonSerializer.Serialize(writer, "circular.out", options);
                    return;
                case VideoEase.CubicIn:
                    JsonSerializer.Serialize(writer, "cubic.in", options);
                    return;
                case VideoEase.CubicInout:
                    JsonSerializer.Serialize(writer, "cubic.inout", options);
                    return;
                case VideoEase.CubicOut:
                    JsonSerializer.Serialize(writer, "cubic.out", options);
                    return;
                case VideoEase.ElasticIn:
                    JsonSerializer.Serialize(writer, "elastic.in", options);
                    return;
                case VideoEase.ElasticInout:
                    JsonSerializer.Serialize(writer, "elastic.inout", options);
                    return;
                case VideoEase.ElasticOut:
                    JsonSerializer.Serialize(writer, "elastic.out", options);
                    return;
                case VideoEase.ExponentialIn:
                    JsonSerializer.Serialize(writer, "exponential.in", options);
                    return;
                case VideoEase.ExponentialInout:
                    JsonSerializer.Serialize(writer, "exponential.inout", options);
                    return;
                case VideoEase.ExponentialOut:
                    JsonSerializer.Serialize(writer, "exponential.out", options);
                    return;
                case VideoEase.LinearNone:
                    JsonSerializer.Serialize(writer, "linear.none", options);
                    return;
                case VideoEase.QuadraticIn:
                    JsonSerializer.Serialize(writer, "quadratic.in", options);
                    return;
                case VideoEase.QuadraticInout:
                    JsonSerializer.Serialize(writer, "quadratic.inout", options);
                    return;
                case VideoEase.QuadraticOut:
                    JsonSerializer.Serialize(writer, "quadratic.out", options);
                    return;
                case VideoEase.QuarticIn:
                    JsonSerializer.Serialize(writer, "quartic.in", options);
                    return;
                case VideoEase.QuarticInout:
                    JsonSerializer.Serialize(writer, "quartic.inout", options);
                    return;
                case VideoEase.QuarticOut:
                    JsonSerializer.Serialize(writer, "quartic.out", options);
                    return;
                case VideoEase.QuinticIn:
                    JsonSerializer.Serialize(writer, "quintic.in", options);
                    return;
                case VideoEase.QuinticInout:
                    JsonSerializer.Serialize(writer, "quintic.inout", options);
                    return;
                case VideoEase.QuinticOut:
                    JsonSerializer.Serialize(writer, "quintic.out", options);
                    return;
                case VideoEase.SinusoidalIn:
                    JsonSerializer.Serialize(writer, "sinusoidal.in", options);
                    return;
                case VideoEase.SinusoidalInout:
                    JsonSerializer.Serialize(writer, "sinusoidal.inout", options);
                    return;
                case VideoEase.SinusoidalOut:
                    JsonSerializer.Serialize(writer, "sinusoidal.out", options);
                    return;
            }
            throw new Exception("Cannot marshal type VideoEase");
        }

        public static readonly VideoEaseConverter Singleton = new VideoEaseConverter();
    }

    internal class VideoMethodConverter : JsonConverter<VideoMethod>
    {
        public override bool CanConvert(Type t) => t == typeof(VideoMethod);

        public override VideoMethod Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "extension":
                    return VideoMethod.Extension;
                case "psr":
                    return VideoMethod.Psr;
                case "screencast":
                    return VideoMethod.Screencast;
            }
            throw new Exception("Cannot unmarshal type VideoMethod");
        }

        public override void Write(Utf8JsonWriter writer, VideoMethod value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case VideoMethod.Extension:
                    JsonSerializer.Serialize(writer, "extension", options);
                    return;
                case VideoMethod.Psr:
                    JsonSerializer.Serialize(writer, "psr", options);
                    return;
                case VideoMethod.Screencast:
                    JsonSerializer.Serialize(writer, "screencast", options);
                    return;
            }
            throw new Exception("Cannot marshal type VideoMethod");
        }

        public static readonly VideoMethodConverter Singleton = new VideoMethodConverter();
    }

    internal class VideoPresetConverter : JsonConverter<VideoPreset>
    {
        public override bool CanConvert(Type t) => t == typeof(VideoPreset);

        public override VideoPreset Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "fast":
                    return VideoPreset.Fast;
                case "faster":
                    return VideoPreset.Faster;
                case "medium":
                    return VideoPreset.Medium;
                case "slow":
                    return VideoPreset.Slow;
                case "slower":
                    return VideoPreset.Slower;
                case "superfast":
                    return VideoPreset.Superfast;
                case "ultrafast":
                    return VideoPreset.Ultrafast;
                case "veryfast":
                    return VideoPreset.Veryfast;
                case "veryslow":
                    return VideoPreset.Veryslow;
            }
            throw new Exception("Cannot unmarshal type VideoPreset");
        }

        public override void Write(Utf8JsonWriter writer, VideoPreset value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case VideoPreset.Fast:
                    JsonSerializer.Serialize(writer, "fast", options);
                    return;
                case VideoPreset.Faster:
                    JsonSerializer.Serialize(writer, "faster", options);
                    return;
                case VideoPreset.Medium:
                    JsonSerializer.Serialize(writer, "medium", options);
                    return;
                case VideoPreset.Slow:
                    JsonSerializer.Serialize(writer, "slow", options);
                    return;
                case VideoPreset.Slower:
                    JsonSerializer.Serialize(writer, "slower", options);
                    return;
                case VideoPreset.Superfast:
                    JsonSerializer.Serialize(writer, "superfast", options);
                    return;
                case VideoPreset.Ultrafast:
                    JsonSerializer.Serialize(writer, "ultrafast", options);
                    return;
                case VideoPreset.Veryfast:
                    JsonSerializer.Serialize(writer, "veryfast", options);
                    return;
                case VideoPreset.Veryslow:
                    JsonSerializer.Serialize(writer, "veryslow", options);
                    return;
            }
            throw new Exception("Cannot marshal type VideoPreset");
        }

        public static readonly VideoPresetConverter Singleton = new VideoPresetConverter();
    }

    internal class WaitUntilConverter : JsonConverter<WaitUntil>
    {
        public override bool CanConvert(Type t) => t == typeof(WaitUntil);

        public override WaitUntil Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "domloaded":
                    return WaitUntil.Domloaded;
                case "loaded":
                    return WaitUntil.Loaded;
                case "mostrequestsfinished":
                    return WaitUntil.Mostrequestsfinished;
                case "requestsfinished":
                    return WaitUntil.Requestsfinished;
            }
            throw new Exception("Cannot unmarshal type WaitUntil");
        }

        public override void Write(Utf8JsonWriter writer, WaitUntil value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case WaitUntil.Domloaded:
                    JsonSerializer.Serialize(writer, "domloaded", options);
                    return;
                case WaitUntil.Loaded:
                    JsonSerializer.Serialize(writer, "loaded", options);
                    return;
                case WaitUntil.Mostrequestsfinished:
                    JsonSerializer.Serialize(writer, "mostrequestsfinished", options);
                    return;
                case WaitUntil.Requestsfinished:
                    JsonSerializer.Serialize(writer, "requestsfinished", options);
                    return;
            }
            throw new Exception("Cannot marshal type WaitUntil");
        }

        public static readonly WaitUntilConverter Singleton = new WaitUntilConverter();
    }
    
    public class DateOnlyConverter : JsonConverter<DateOnly>
    {
        private readonly string serializationFormat;
        public DateOnlyConverter() : this(null) { }

        public DateOnlyConverter(string? serializationFormat)
        {
                this.serializationFormat = serializationFormat ?? "yyyy-MM-dd";
        }

        public override DateOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
                var value = reader.GetString();
                return DateOnly.Parse(value!);
        }

        public override void Write(Utf8JsonWriter writer, DateOnly value, JsonSerializerOptions options)
                => writer.WriteStringValue(value.ToString(serializationFormat));
    }

    public class TimeOnlyConverter : JsonConverter<TimeOnly>
    {
        private readonly string serializationFormat;

        public TimeOnlyConverter() : this(null) { }

        public TimeOnlyConverter(string? serializationFormat)
        {
                this.serializationFormat = serializationFormat ?? "HH:mm:ss.fff";
        }

        public override TimeOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
                var value = reader.GetString();
                return TimeOnly.Parse(value!);
        }

        public override void Write(Utf8JsonWriter writer, TimeOnly value, JsonSerializerOptions options)
                => writer.WriteStringValue(value.ToString(serializationFormat));
    }

    internal class IsoDateTimeOffsetConverter : JsonConverter<DateTimeOffset>
    {
        public override bool CanConvert(Type t) => t == typeof(DateTimeOffset);

        private const string DefaultDateTimeFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

        private DateTimeStyles _dateTimeStyles = DateTimeStyles.RoundtripKind;
        private string? _dateTimeFormat;
        private CultureInfo? _culture;

        public DateTimeStyles DateTimeStyles
        {
                get => _dateTimeStyles;
                set => _dateTimeStyles = value;
        }

        public string? DateTimeFormat
        {
                get => _dateTimeFormat ?? string.Empty;
                set => _dateTimeFormat = (string.IsNullOrEmpty(value)) ? null : value;
        }

        public CultureInfo Culture
        {
                get => _culture ?? CultureInfo.CurrentCulture;
                set => _culture = value;
        }

        public override void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options)
        {
                string text;


                if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal
                        || (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
                {
                        value = value.ToUniversalTime();
                }

                text = value.ToString(_dateTimeFormat ?? DefaultDateTimeFormat, Culture);

                writer.WriteStringValue(text);
        }

        public override DateTimeOffset Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
                string? dateText = reader.GetString();

                if (string.IsNullOrEmpty(dateText) == false)
                {
                        if (!string.IsNullOrEmpty(_dateTimeFormat))
                        {
                                return DateTimeOffset.ParseExact(dateText, _dateTimeFormat, Culture, _dateTimeStyles);
                        }
                        else
                        {
                                return DateTimeOffset.Parse(dateText, Culture, _dateTimeStyles);
                        }
                }
                else
                {
                        return default(DateTimeOffset);
                }
        }


        public static readonly IsoDateTimeOffsetConverter Singleton = new IsoDateTimeOffsetConverter();
    }
}
#pragma warning restore CS8618
#pragma warning restore CS8601
#pragma warning restore CS8603
